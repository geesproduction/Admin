/*
 * Decompiled with CFR 0.0.
 * 
 * Could not load the following classes:
 *  java.lang.Double
 *  java.lang.Float
 *  java.lang.Math
 *  java.lang.Object
 */
package lecho.lib.hellocharts.util;

import lecho.lib.hellocharts.util.AxisAutoValues;

public class FloatUtils {
    public static final int[] POW10 = new int[]{1, 10, 100, 1000, 10000, 100000, 1000000};

    /*
     * Enabled aggressive block sorting
     */
    public static boolean almostEqual(float f, float f2, float f3, float f4) {
        float f5;
        float f6;
        float f7;
        float f8 = Math.abs((float)(f - f2));
        return f8 <= f3 || f8 <= (f5 = (f7 = Math.abs((float)f)) > (f6 = Math.abs((float)f2)) ? f7 : f6) * f4;
    }

    public static void computeAutoGeneratedAxisValues(float f, float f2, int n, AxisAutoValues axisAutoValues) {
        double d;
        double d2 = f2 - f;
        if (n == 0 || d2 <= 0.0) {
            axisAutoValues.values = new float[0];
            axisAutoValues.valuesNumber = 0;
            return;
        }
        double d3 = FloatUtils.roundToOneSignificantFigure(d2 / (double)n);
        if ((int)(d3 / (d = Math.pow((double)10.0, (double)((int)Math.log10((double)d3))))) > 5) {
            d3 = Math.floor((double)(10.0 * d));
        }
        double d4 = d3 * Math.ceil((double)((double)f / d3));
        double d5 = FloatUtils.nextUp(d3 * Math.floor((double)((double)f2 / d3)));
        int n2 = 0;
        for (double d6 = d4; d6 <= d5; d6 += d3) {
            ++n2;
        }
        axisAutoValues.valuesNumber = n2;
        if (axisAutoValues.values.length < n2) {
            axisAutoValues.values = new float[n2];
        }
        double d7 = d4;
        for (int i = 0; i < n2; ++i) {
            axisAutoValues.values[i] = (float)d7;
            d7 += d3;
        }
        if (d3 < 1.0) {
            axisAutoValues.decimals = (int)Math.ceil((double)(-Math.log10((double)d3)));
            return;
        }
        axisAutoValues.decimals = 0;
    }

    public static int formatFloat(char[] arrc, float f, int n, int n2, char c) {
        if (n2 >= POW10.length) {
            arrc[n - 1] = 46;
            return 1;
        }
        if (f == 0.0f) {
            arrc[n - 1] = 48;
            return 1;
        }
        float f2 = f FCMPG 0.0f;
        boolean bl = false;
        if (f2 < 0) {
            bl = true;
            f = -f;
        }
        if (n2 > POW10.length) {
            n2 = -1 + POW10.length;
        }
        long l = Math.round((float)(f * (float)POW10[n2]));
        int n3 = n - 1;
        int n4 = 0;
        int n5 = n3;
        while (l != 0L || n4 < n2 + 1) {
            int n6 = (int)(l % 10L);
            l /= 10L;
            int n7 = n5 - 1;
            arrc[n5] = (char)(n6 + 48);
            if (++n4 == n2) {
                int n8 = n7 - 1;
                arrc[n7] = c;
                ++n4;
                n7 = n8;
            }
            n5 = n7;
        }
        if (arrc[n5 + 1] == c) {
            int n9 = n5 - 1;
            arrc[n5] = 48;
            ++n4;
            n5 = n9;
        }
        if (bl) {
            n5 - 1;
            arrc[n5] = 45;
            return n4 + 1;
        }
        return n4;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static double nextDown(double d) {
        int n;
        if (Double.isNaN((double)d) || d == Double.NEGATIVE_INFINITY) {
            return d;
        }
        if (d == 0.0) {
            return -1.401298464324817E-45;
        }
        long l = Double.doubleToRawLongBits((double)d);
        if (d > 0.0) {
            n = -1;
            do {
                return Double.longBitsToDouble((long)(l + (long)n));
                break;
            } while (true);
        }
        n = 1;
        return Double.longBitsToDouble((long)(l + (long)n));
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static float nextDownF(float f) {
        int n;
        if (Float.isNaN((float)f) || f == Float.NEGATIVE_INFINITY) {
            return f;
        }
        if (f == 0.0f) {
            return -1.4E-45f;
        }
        int n2 = Float.floatToRawIntBits((float)f);
        if (f > 0.0f) {
            n = -1;
            do {
                return Float.intBitsToFloat((int)(n + n2));
                break;
            } while (true);
        }
        n = 1;
        return Float.intBitsToFloat((int)(n + n2));
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static double nextUp(double d) {
        int n;
        if (Double.isNaN((double)d) || d == Double.POSITIVE_INFINITY) {
            return d;
        }
        double d2 = d + 0.0;
        long l = Double.doubleToRawLongBits((double)d2);
        if (d2 >= 0.0) {
            n = 1;
            do {
                return Double.longBitsToDouble((long)(l + (long)n));
                break;
            } while (true);
        }
        n = -1;
        return Double.longBitsToDouble((long)(l + (long)n));
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static float nextUpF(float f) {
        int n;
        if (Float.isNaN((float)f) || f == Float.POSITIVE_INFINITY) {
            return f;
        }
        float f2 = f + 0.0f;
        int n2 = Float.floatToRawIntBits((float)f2);
        if (f2 >= 0.0f) {
            n = 1;
            do {
                return Float.intBitsToFloat((int)(n + n2));
                break;
            } while (true);
        }
        n = -1;
        return Float.intBitsToFloat((int)(n + n2));
    }

    /*
     * Enabled aggressive block sorting
     */
    public static float roundToOneSignificantFigure(double d) {
        double d2 = d < 0.0 ? -d : d;
        float f = (float)Math.pow((double)10.0, (double)(1 - (int)Math.ceil((double)((float)Math.log10((double)d2)))));
        return (float)Math.round((double)(d * (double)f)) / f;
    }
}

